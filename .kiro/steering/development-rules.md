# 開発ルール

## エラーハンドリングとエスカレーション

### 3回ルール

同じ箇所で3回作業してもうまく修正できない場合、以下の手順を実行する：

1. **作業を一旦停止する**
2. **ユーザーに方針確認を依頼する**
3. **問題分析ドキュメントを作成する**

### 問題分析ドキュメントの構成

以下の5つの項目を含むドキュメントを作成し、ユーザーに提示する：

#### 1. どのファイルに

- 対象ファイルのパス
- ファイルの役割
- 関連するファイル

#### 2. どのような作業をして

- 試行1: 実施した内容
- 試行2: 実施した内容
- 試行3: 実施した内容

各試行について：

- 実施した変更内容
- 使用したコマンドやツール
- 期待した結果

#### 3. どういう結果になったか

- 試行1の結果: エラーメッセージ、動作状況
- 試行2の結果: エラーメッセージ、動作状況
- 試行3の結果: エラーメッセージ、動作状況

各結果について：

- 実際に起きたこと
- エラーメッセージの全文
- ログやスタックトレース

#### 4. 次に必要なアプローチは何か

- 考えられる原因の仮説
- 試していないアプローチ
- 推奨する次のステップ
- 代替案

#### 5. 不足している情報は何か

- 確認が必要な設定
- 必要なドキュメント
- 追加で必要な情報
- ユーザーに確認したい事項

### ドキュメントのテンプレート

```markdown
# 問題分析レポート

## 概要

[問題の簡潔な説明]

## 1. 対象ファイル

- **ファイルパス**:
- **ファイルの役割**:
- **関連ファイル**:

## 2. 実施した作業

### 試行1

- **変更内容**:
- **コマンド/ツール**:
- **期待した結果**:

### 試行2

- **変更内容**:
- **コマンド/ツール**:
- **期待した結果**:

### 試行3

- **変更内容**:
- **コマンド/ツール**:
- **期待した結果**:

## 3. 結果

### 試行1の結果

- **実際の動作**:
- **エラーメッセージ**:
```

[エラーメッセージ全文]

```

### 試行2の結果
- **実際の動作**:
- **エラーメッセージ**:
```

[エラーメッセージ全文]

```

### 試行3の結果
- **実際の動作**:
- **エラーメッセージ**:
```

[エラーメッセージ全文]

```

## 4. 次に必要なアプローチ

### 原因の仮説
1.
2.
3.

### 試していないアプローチ
1.
2.
3.

### 推奨する次のステップ
1.
2.
3.

### 代替案
1.
2.

## 5. 不足している情報

### 確認が必要な設定
-

### 必要なドキュメント
-

### 追加で必要な情報
-

### ユーザーに確認したい事項
-
```

## 適用例

### 例1: テストファイルの変換エラー

```markdown
# 問題分析レポート

## 概要

next-intlのモックが正しく適用されず、テストが失敗する

## 1. 対象ファイル

- **ファイルパス**: `src/components/DateTimeConverter.test.tsx`
- **ファイルの役割**: DateTimeConverterコンポーネントの単体テスト
- **関連ファイル**:
  - `vitest.config.ts`
  - `src/__mocks__/next-intl.tsx`

## 2. 実施した作業

### 試行1

- **変更内容**: vitest.config.tsにserver.deps.inlineを追加
- **コマンド/ツール**: `npm run test src/components/DateTimeConverter.test.tsx`
- **期待した結果**: モックが適用されてテストがパスする

### 試行2

- **変更内容**: モックファイルのパスを明示的に指定
- **コマンド/ツール**: `npm run test src/components/DateTimeConverter.test.tsx`
- **期待した結果**: モックが適用されてテストがパスする

### 試行3

- **変更内容**: vi.mock()を使用してテストファイル内で直接モック
- **コマンド/ツール**: `npm run test src/components/DateTimeConverter.test.tsx`
- **期待した結果**: モックが適用されてテストがパスする

## 3. 結果

### 試行1の結果

- **実際の動作**: テストが失敗
- **エラーメッセージ**:
```

Error: Cannot find module 'next-intl'
at src/components/DateTimeConverter.test.tsx:12:5

```

### 試行2の結果
- **実際の動作**: テストが失敗
- **エラーメッセージ**:
```

Error: [vitest] Cannot mock "next-intl" because it is not loaded by Vite

```

### 試行3の結果
- **実際の動作**: テストが失敗
- **エラーメッセージ**:
```

TypeError: useTranslations is not a function
at DateTimeConverter (src/components/DateTimeConverter.tsx:15:20)

```

## 4. 次に必要なアプローチ

### 原因の仮説
1. next-intlがESMモジュールとして扱われ、Vitestの変換パイプラインに含まれていない
2. モックファイルの配置場所が正しくない
3. Vitestのモックシステムとnext-intlの相性問題

### 試していないアプローチ
1. `server.deps.external`を使用してnext-intlを外部依存として扱う
2. `vi.hoisted()`を使用してモックを巻き上げる
3. next-intlの公式ドキュメントでVitest対応を確認

### 推奨する次のステップ
1. next-intlの公式ドキュメントでVitestでのテスト方法を確認
2. Vitestの公式ドキュメントでESMモジュールのモック方法を確認
3. 他のプロジェクトでnext-intl + Vitestの実装例を調査

### 代替案
1. next-intlを使用しないテストダブルを作成
2. 該当コンポーネントのテストを一時的にスキップ
3. Jestに戻す（最終手段）

## 5. 不足している情報

### 確認が必要な設定
- next-intlのバージョン
- Vitestのバージョン互換性
- 他のESMモジュールのモック方法

### 必要なドキュメント
- next-intl公式のテストガイド
- Vitestの高度なモック設定

### 追加で必要な情報
- 他のプロジェクトでの成功事例
- next-intlメンテナーの推奨方法

### ユーザーに確認したい事項
- next-intlのモックを諦めて、テストダブルを作成することは許容できるか
- 一時的にこのテストをスキップして、後で対応することは可能か
- Jestに戻すことも選択肢として検討すべきか
```

## 注意事項

- 3回の試行は「同じアプローチの繰り返し」ではなく、「異なるアプローチの試行」であること
- 各試行で学んだことを次の試行に活かすこと
- 問題分析ドキュメントは客観的かつ具体的に記述すること
- エラーメッセージは省略せず全文を記載すること
- 推測と事実を明確に区別すること
